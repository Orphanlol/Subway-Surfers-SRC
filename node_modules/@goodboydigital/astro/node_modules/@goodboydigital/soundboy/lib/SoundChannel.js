var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { SoundController } from './SoundController';
/**
 * A SoundChannel provides a way of playing back and controlling multiple sounds.
 * Volume, pause
 */
var SoundChannel = /** @class */ (function (_super) {
    __extends(SoundChannel, _super);
    function SoundChannel() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.sounds = new Set();
        _this._singlefile = false;
        _this._crossFadeDuration = 0;
        return _this;
    }
    /**
     * Adds a sound instance to this channel.
     *
     * @param sound - sound instance to add to channel
     */
    SoundChannel.prototype.addSound = function (sound) {
        var _this = this;
        if (this._singlefile) {
            if (this.sounds.size) {
                var crossFade_1 = this._crossFadeDuration > 0;
                this.sounds.forEach(function (existingSound) {
                    existingSound.interrupt();
                    if (crossFade_1) {
                        existingSound.fadeOut(_this._crossFadeDuration, function () { return existingSound.stop(); });
                    }
                    else {
                        existingSound.stop();
                    }
                });
                if (crossFade_1) {
                    var volume = sound.volume;
                    sound.volume = 0;
                    sound.fadeTo(volume, this._crossFadeDuration);
                }
            }
        }
        this.sounds.add(sound);
        sound.disposed.connect(function (sound) { return _this.removeSound(sound); });
        sound.resume();
        this.addChild(sound);
    };
    Object.defineProperty(SoundChannel.prototype, "singleFile", {
        /**
         * If set to true, this channel will only play one sound at a time.
         * A new sound added to the channel will interrupt and stop any existing sound on the channel,
         * unless the sound was played with it's options.wontInterrupt set to false
         */
        set: function (value) {
            this._singlefile = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SoundChannel.prototype, "crossFadeDuration", {
        /**
         * duration of cross fade between sounds on a single file channel
         */
        set: function (value) {
            this._crossFadeDuration = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SoundChannel.prototype, "wouldBeInterrupted", {
        /**
         * Will playing a sound on this channel interrupt another sound?
         *
         * @readonly
         */
        get: function () {
            return this.sounds.size && this._singlefile;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * restart all sounds on the channel
     */
    SoundChannel.prototype.restart = function () {
        this.forEach(function (sound) { return sound.restart(); });
    };
    /**
     * do anything you like to all sounds on the channel
     *
     * @param callback - the function to execute on each sound instance
     */
    SoundChannel.prototype.forEach = function (callback) {
        this.sounds.forEach(callback);
    };
    /**
     * stops a sound from playing, this will kill the sound completely,
     * if you want to maintain a reference to the sound then use pause and restart/resume
     */
    SoundChannel.prototype.stop = function (executeCallbacks) {
        this.forEach(function (sound) { return sound.stop(executeCallbacks); });
    };
    SoundChannel.prototype.removeSound = function (sound) {
        this.sounds.delete(sound);
        this.removeChild(sound);
    };
    return SoundChannel;
}(SoundController));
export default SoundChannel;
