var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Signal } from 'typed-signals';
import { SoundController } from './SoundController';
/**
 * A representation of a single sound
 * When created a sound will play
 * Unless the sound is looping, once complete or stopped, sound is disposed - event handlers removed etc
 *
 */
var SoundInstance = /** @class */ (function (_super) {
    __extends(SoundInstance, _super);
    /**
     *
     * @param id - the id this sound was registered with
     * @param baseVolume - the volume this sound was registered with, defaults to 1. The base volume is never modified, so is
     * only used to set the overall level of a sound relative to other sounds.
     */
    function SoundInstance(id, baseVolume) {
        if (baseVolume === void 0) { baseVolume = 1; }
        var _this = _super.call(this) || this;
        /**
         * dispatches when the sound has fully completed, including any additional loops
         */
        _this.completed = new Signal();
        /**
         * dispatches at the start of each additional loop
         */
        _this.looped = new Signal();
        /**
         * dispatches when sound is being disposed, after it has stopped and all other signals have been dispatched,
         * this is for information only, the sound should not be re-used at this point
         */
        _this.disposed = new Signal();
        // these should only be needed in this base class
        _this.loopsRemaining = 1;
        _this._loop = false;
        _this._keepAlive = false; // used to prevent disposal on stop if restarted in onComplete handler
        _this.callbackOnInterrupt = false;
        _this.canPropogate = false;
        /**
         * this should be called when the sound finishes playing, concrete implementations will need ot wire this up
         */
        _this.boundOnCompleteHandler = function () { return _this._onCompleteHandler(); };
        _this._id = id;
        _this._baseVolume = baseVolume || 1;
        return _this;
    }
    Object.defineProperty(SoundInstance.prototype, "id", {
        /**
         * id the sound was registered with
         */
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * this needs to be called at the end of a subclass' constructor so we can configure
     * the sound based on the options passed into the constructor
     * @param options - options to initialise sound with
     */
    SoundInstance.prototype.postConstructor = function (options) {
        if (options === void 0) { options = {}; }
        if (options.loops) {
            this.loopsRemaining = options.loops === true ? Infinity : options.loops;
            // set loop for this instance to true if more than one loop specified
            this._loop = this.loopsRemaining > 1;
        }
        else {
            this.loopsRemaining = 1;
        }
        this.volume = options.volume !== undefined ? options.volume : 1;
        if (options.panning) {
            this.panning = options.panning;
        }
        this.rate = options.rate !== undefined ? options.rate : 1;
        this.callback = options.callback;
        this.callbackScope = options.callbackScope;
        this.callbackOnInterrupt = !!options.callbackOnInterrupt;
        this._addListeners();
    };
    /**
     * seek to the specified position
     *
     */
    SoundInstance.prototype.seek = function (seconds) {
        this._seek(seconds);
        this._keepAlive = true;
    };
    /**
     * seek to the specified position and pause
     *
     */
    SoundInstance.prototype.cue = function (seconds) {
        this._seek(seconds);
        this.paused = true;
        this._keepAlive = true;
    };
    /**
     * restart sound from the beginning
     */
    SoundInstance.prototype.restart = function () {
        this._seek(0);
        if (!this.accumulatedPaused) {
            this._resume();
        }
        this._keepAlive = true;
    };
    /**
     * This should only be used by the SoundChannel, so we can execute callback if we are supposed to
     */
    SoundInstance.prototype.interrupt = function () {
        if (this.callbackOnInterrupt) {
            this.executeCallback();
        }
    };
    /**
     * stops a sound. Once stopped, a sound is disposed of, unless a callback restarts, seeks or cues the sound
     *
     */
    SoundInstance.prototype.stop = function (executeCallback) {
        if (executeCallback === void 0) { executeCallback = false; }
        this._stop();
        this._keepAlive = false;
        // execute callback if there is one and we've been told to
        if (this.callback && executeCallback) {
            this.executeCallback();
        }
        if (!this._keepAlive) {
            this.dispose();
        }
    };
    /**
     * overrides super class method, this is the end of the propogation road, we need to actually set the volume of the sound
     */
    SoundInstance.prototype.propogateVolume = function () {
        var volume = this.accumulatedMuted ? 0 : this.accumulatedVolume;
        this._setCalculatedVolume(volume * this._baseVolume);
    };
    /**
     * override super class method, implement muted state
     */
    SoundInstance.prototype.propogateMuted = function () {
        var volume = this.accumulatedMuted ? 0 : this.accumulatedVolume;
        this._setCalculatedVolume(volume * this._baseVolume);
    };
    /**
     * override super class method, implement paused state
     */
    SoundInstance.prototype.propogatePaused = function () {
        this.accumulatedPaused ? this._pause() : this._resume();
    };
    /**
     * override super class method, set the calculated rate on the sound
     */
    SoundInstance.prototype.propogateRate = function () {
        this._setCalculatedRate(this.accumulatedRate);
    };
    /**
     * override super class method, implement the entire state on the sound
     */
    SoundInstance.prototype.propogateState = function () {
        this.propogateVolume();
        this.propogatePaused();
        this.propogateMuted();
        this.propogateRate();
    };
    SoundInstance.prototype._onCompleteHandler = function () {
        if (this._loop) {
            this.loopsRemaining -= 1;
            if (this.loopsRemaining !== 0) {
                // we have more loops to play, just let the sound continue looping
                this.restart();
                this.looped.emit(this);
                return;
            }
        }
        // all done: notify, stop and dispose
        this._keepAlive = false;
        this.executeCallback();
        this.completed.emit(this);
        // any operations on this sound instance that should result in the sound
        // not being disposed will set the keepAlive flag to true
        if (!this._keepAlive) {
            this.stop();
        }
    };
    /**
     * executes callback if there is one
     */
    SoundInstance.prototype.executeCallback = function () {
        if (this.callback) {
            if (this.callbackScope) {
                this.callback.call(this.callbackScope, this);
            }
            else {
                this.callback(this);
            }
            // clear callback so we don't accidentally call it again (e.g. in stop())
            this.callback = null;
        }
    };
    /**
     * tidy up, after this should not be used any more
     */
    SoundInstance.prototype.dispose = function () {
        // remove implementation specific listeners
        this._removeListeners();
        // notify channel for removal:
        this.disposed.emit(this);
        // disconnect everything
        this.disposed.disconnectAll();
        this.looped.disconnectAll();
        this.completed.disconnectAll();
    };
    Object.defineProperty(SoundInstance.prototype, "hasLoopsRemaining", {
        get: function () {
            return this._loop && this.loopsRemaining > 1;
        },
        enumerable: false,
        configurable: true
    });
    return SoundInstance;
}(SoundController));
export { SoundInstance };
