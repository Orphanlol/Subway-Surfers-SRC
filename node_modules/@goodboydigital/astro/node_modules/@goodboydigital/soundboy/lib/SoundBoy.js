var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { SoundCollection } from './SoundCollection';
import { HowlerSoundFactory } from './howler/HowlerSound';
import { Signal } from 'typed-signals';
import SoundChannel from './SoundChannel';
import { SoundCollectionInstance } from './SoundCollectionInstance';
import { SoundController } from './SoundController';
var defaultOptions = {
    id: '',
    src: '',
    preload: false,
    loop: false,
    volume: 1,
};
/**
 * registers, plays and provides various mechanisms for controlling sounds on multiple channels
 */
var SoundBoy = /** @class */ (function (_super) {
    __extends(SoundBoy, _super);
    function SoundBoy() {
        var _this = _super.call(this) || this;
        _this.systemPauseChanged = new Signal();
        _this.channelsById = new Map();
        _this.soundsById = new Map();
        _this.collectionsById = new Map();
        _this.preload = true;
        _this.soundFactory = new HowlerSoundFactory();
        _this.extensions = ['ogg', 'mp3']; // TODO: enable configuring this externally
        _this.addChannel(SoundBoy.CHANNEL_SFX);
        _this.addChannel(SoundBoy.CHANNEL_MUSIC);
        _this.addChannel(SoundBoy.CHANNEL_VO);
        _this.voChannel.singleFile = true;
        _this.musicChannel.singleFile = true;
        _this.musicChannel.crossFadeDuration = 2;
        _this.system = new SoundController();
        _this.system.addChild(_this);
        return _this;
    }
    Object.defineProperty(SoundBoy.prototype, "systemMuteChanged", {
        get: function () {
            return this.system.muteChanged;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Register a sound with the provided options
     *
     * @param options - specifies the id and url(s), also determines the options for preload, as well as default options for all sound instances created for this sound.
     *                  volume determines the maximum volume for the sound, a SoundInstance created from this sound will have this volume when it's
     *                  volume is set to 1.
     *
     */
    SoundBoy.prototype.registerSound = function (options) {
        if (this.soundsById.get(options.id)) {
            console.warn("SoundBoy: duplicate sound id being registered: " + options.id);
        }
        if (options !== defaultOptions) {
            options = Object.assign({}, defaultOptions, options);
        }
        // convert url to array of urls TODO: this should probably be done externally, or just pass a string in and always construct array
        if (typeof options.src === 'string') {
            var src = void 0;
            var format = options.src.split('.').pop();
            if (format === 'ogg' || format === 'mp3' || format === 'wav') {
                src = [options.src];
            }
            else {
                src = this.extensions.map(function (extension) { return options.src + "." + extension; });
            }
            options.src = src;
        }
        this.soundsById.set(options.id, options);
        this.soundFactory.registerSound(options);
    };
    /**
     * Play a sound on the default (sfx) channel
     *
     * @param id - id the sound was registered with
     * @param options - used to initialise the sound
     * @returns a sound instance
     */
    SoundBoy.prototype.play = function (id, options) {
        return this.playSfx(id, options);
    };
    /**
     * Play a sound on the SFX channel
     *
     * @param id - id the sound was registered with
     * @param options - options used to initialise the sound
     * @returns a sound instance
     */
    SoundBoy.prototype.playSfx = function (id, options) {
        return this.playOnChannel(id, SoundBoy.CHANNEL_SFX, options);
    };
    /**
     * Play a sound on the music channel
     *
     * @param id - id the sound was registered with
     * @param options - options used to initialise the sound
     * @returns a sound instance
     */
    SoundBoy.prototype.playMusic = function (id, options) {
        return this.playOnChannel(id, SoundBoy.CHANNEL_MUSIC, options);
    };
    /**
     * Play a sound on the VO channel
     *
     * @param id - id the sound was registered with
     * @param options - options used to initialise the sound
     * @returns a sound instance
     */
    SoundBoy.prototype.playVo = function (id, options) {
        return this.playOnChannel(id, SoundBoy.CHANNEL_VO, options);
    };
    /**
     * Play a sound on the specified channel,
     * all requests to play a sound are eventually routed through this method
     *
     * @param id - id the sound was registered with
     * @param channelId - id of the channel
     * @param options - options used to initialise the sound
     * @returns a sound instance
     */
    SoundBoy.prototype.playOnChannel = function (id, channelId, options) {
        if (options === void 0) { options = {}; }
        var channel = this.getChannelById(channelId);
        if (!channel) {
            console.warn("SoundBoy: playOnChannel : invalid sound channel id: " + channelId);
        }
        // should the channel play this sound?
        if (options.wontInterrupt && channel.wouldBeInterrupted) {
            return null;
        }
        var registeredOptions = this.soundsById.get(id);
        if (!registeredOptions) {
            // if no sound registered, check collections:
            var collection = this.collectionsById.get(id);
            if (!collection) {
                console.warn("SoundBoy: no sound or collection registered with id: " + id);
                // if no collection registered, attempt to register a sound using the id as a url
                this.registerSound({
                    id: id,
                    src: id,
                });
                return this.playOnChannel(id, channelId, options);
            }
            // SoundCollectionInstance will  take care of everything from here
            return new SoundCollectionInstance(id, collection, channelId, options);
        }
        // set loops to infinite if sound was registered to loop by default (allow override via SoundInstanceOptions)
        if (!options.loops && registeredOptions.loop) {
            options.loops = Infinity;
        }
        var soundInstance = this.soundFactory.factorySoundInstance(id, registeredOptions.volume, options);
        if (!soundInstance) {
            throw new Error("problem creating sound instance with id: " + id);
        }
        channel.addSound(soundInstance);
        return soundInstance;
    };
    Object.defineProperty(SoundBoy.prototype, "systemMuted", {
        /**
         * the global muted state, should only be used to respond to system level events
         * such as changes in app/browser tab visibility
         */
        get: function () {
            return this.system.muted;
        },
        set: function (value) {
            if (value === this.system.muted)
                return;
            this.system.muted = value;
            this.systemMuteChanged.emit(value);
        },
        enumerable: false,
        configurable: true
    });
    SoundBoy.prototype.systemMute = function (mute) {
        if (mute === void 0) { mute = true; }
        this.systemMuted = mute;
    };
    Object.defineProperty(SoundBoy.prototype, "systemPaused", {
        /**
         * the global paused state, should only be used to respond to system level events
         * such as changes in app/browser tab visibility
         */
        get: function () {
            return this.system.paused;
        },
        set: function (value) {
            if (value === this.system.paused)
                return;
            this.system.paused = value;
            this.systemPauseChanged.emit(value);
        },
        enumerable: false,
        configurable: true
    });
    SoundBoy.prototype.systemPause = function (pause) {
        if (pause === void 0) { pause = true; }
        this.systemPaused = pause;
    };
    /**
     * stop all sounds, callbacks will not be executed
     */
    SoundBoy.prototype.stop = function () {
        this.channelsById.forEach(function (channel) { return channel.stop(); });
    };
    /**
     * Register a sound collecion using the provided data
     * e.g.
     * ```
     * SoundBoy.registerCollection({
     *    id: 'gun-shot',
     *    selectionMode: SELECTION_MODE.RANDOM,
     *    sequenceMode: SEQUENCE_MODE.SINGLE,
     *    children: [
     *        { id: 'shot1' },
     *        { id: 'shot2' },
     *        { id: 'shot3' },
     *        { id: 'shot4' },
     *        { id: 'shot5' },
     *    ]
     * });
     * SoundBoy.playSfx('gun-shot');
     * // will play a single gun shot, randomly selected from the children
     *
     * SoundBoy.registerCollection({
     *    id: 'count-to-5',
     *    selectionMode: SELECTION_MODE.LINEAR,
     *    sequenceMode: SEQUENCE_MODE.GROUP,
     *    children: [
     *        { id: 'number1' },
     *        { id: 'number2' },
     *        { id: 'number3' },
     *        { id: 'number4' },
     *        { id: 'number5' },
     *    ]
     * });
     * SoundBoy.playVo('count-to-5', { loops: true });
     * // will count from one to five, in order, over and over again
     *
     * Because they behave just like a single sound, SoundCollections can also be nested,
     * just add a child with the registered collection id just as you would a normal sound.
     *```
     * @param data - sound collection definition data
     */
    SoundBoy.prototype.registerCollection = function (data) {
        this.collectionsById.set(data.id, new SoundCollection(data));
    };
    /**
     * add a new sound channel with the specified id
     *
     * @param id - id of new channel
     * @returns the newly created sound channel
     */
    SoundBoy.prototype.addChannel = function (id) {
        if (this.channelsById.get(id)) {
            console.warn("SoundChannel with id: " + id + " already exists, we will use the existing one!");
            return this.channelsById.get(id);
        }
        var channel = new SoundChannel();
        this.channelsById.set(id, channel);
        this.addChild(channel);
        return channel;
    };
    /**
     * return the SoundChannnel registered with the given id
     *
     * @param id - id the channel was registered with
     * @returns the sound channel
     */
    SoundBoy.prototype.getChannelById = function (id) {
        return this.channelsById.get(id);
    };
    Object.defineProperty(SoundBoy.prototype, "musicChannel", {
        /**
         * a channel to play music on, by default this is a single file sound channel with crossFade set to 2 seconds
         *
         * @readonly
         */
        get: function () {
            return this.channelsById.get(SoundBoy.CHANNEL_MUSIC);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SoundBoy.prototype, "sfxChannel", {
        /**
         * a channel to play sfx on
         *
         * @readonly
         */
        get: function () {
            return this.channelsById.get(SoundBoy.CHANNEL_SFX);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SoundBoy.prototype, "voChannel", {
        /**
         * a channel to play vo on, by default this is a single file sound channel
         *
         * @readonly
         */
        get: function () {
            return this.channelsById.get(SoundBoy.CHANNEL_VO);
        },
        enumerable: false,
        configurable: true
    });
    SoundBoy.CHANNEL_SFX = 'sfx';
    SoundBoy.CHANNEL_VO = 'vo';
    SoundBoy.CHANNEL_MUSIC = 'music';
    return SoundBoy;
}(SoundController));
export default new SoundBoy();
