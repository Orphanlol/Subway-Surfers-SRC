import { Signal } from 'typed-signals';
import { gsap } from 'gsap';
var defaultState = {
    volume: 1,
    muted: false,
    paused: false,
    rate: 1,
};
/**
 * Hides away the complexities of managing accumulated state across the hierarchy of SoundBoy,
 * it's SoundChannels and their SoundInstances, all of which extend this base class.
 *
 * A SoundController is responsible of keeping track of it's own internal state, calculating it's
 * accumulated state based on the properties of it's ancestors, and propogating this state down to
 * it's descendent SoundControllers, until reaching any SoundInstances, which will apply the final
 * calculated state to the actual sound.
 */
var SoundController = /** @class */ (function () {
    function SoundController() {
        this.muteChanged = new Signal();
        // child sound contollers will accumulate the state of their parent(s)
        this._children = new Set();
        this.internal = Object.assign({}, defaultState);
        this.inherited = Object.assign({}, defaultState);
    }
    Object.defineProperty(SoundController.prototype, "volume", {
        /**
         * the internal volume of this instance, actual volume will depend on inherited state from ancestors
         */
        get: function () {
            return this.internal.volume;
        },
        set: function (value) {
            if (value === this.internal.volume)
                return;
            this.internal.volume = value;
            this.propogateVolume();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "rate", {
        /**
         * the internal rate of this instance, actual rate will depend on inherited state from ancestors
         */
        get: function () {
            return this.internal.rate;
        },
        set: function (value) {
            if (value === this.internal.rate)
                return;
            this.internal.rate = value;
            this.propogateRate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "muted", {
        /**
         * the internal mute state of this instance, actual mute state will also depend on inherited state
         * muted sounds will still play, so timing and callback
         * execution will remain consistent regardless of muted state
         */
        get: function () {
            return this.internal.muted;
        },
        set: function (value) {
            if (value === this.internal.muted)
                return;
            this.internal.muted = value;
            this.propogateMuted();
            this.muteChanged.emit(value);
        },
        enumerable: true,
        configurable: true
    });
    SoundController.prototype.mute = function (value) {
        if (value === void 0) { value = true; }
        this.muted = value;
    };
    Object.defineProperty(SoundController.prototype, "paused", {
        /**
         * the internal pause state of this instance, actual pause state may also depend on inherited state from ancestors
         */
        get: function () {
            return this.internal.paused;
        },
        set: function (value) {
            if (value === this.internal.paused)
                return;
            this.internal.paused = value;
            this.propogatePaused();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * pause this instance
     */
    SoundController.prototype.pause = function () {
        this.paused = true;
    };
    /**
     * unpause this instance
     */
    SoundController.prototype.resume = function () {
        this.paused = false;
    };
    /**
     * add a child, children will calculate their volume, paused and muted state
     * based on the state of all of their ancestors, and propogate this state down
     * to any descendents
     *
     * @param child - the sound controller to add as a child
     * @returns
     */
    SoundController.prototype.addChild = function (child) {
        if (!this._children.has(child)) {
            this._children.add(child);
            child.inheritState(this.accumulatedState);
            return true;
        }
        return false;
    };
    /**
     * removes a child sound controller
     *
     * @param child - the child to remove
     */
    SoundController.prototype.removeChild = function (child) {
        this._children.delete(child);
    };
    /*
    * These methods propogate properties down through the SoundController's descendents, ensuring the SoundInstance at the end
    * implements the correct value. For example, a sounds actual volume is the product of the Soundboy master volume, the sounds
    * SoundChannel volume, and the sound instance's volume.
    * SouundInstance overrides these methods to apply the accumulated value to the actual sound.
    */
    SoundController.prototype.propogateState = function () {
        var _this = this;
        this.propogateValue(function (child) { return child.inheritState(_this.accumulatedState); });
    };
    SoundController.prototype.propogateVolume = function () {
        var _this = this;
        this.propogateValue(function (child) { return child.inheritVolume(_this.accumulatedVolume); });
    };
    SoundController.prototype.propogatePaused = function () {
        var _this = this;
        this.propogateValue(function (child) { return child.inheritPaused(_this.accumulatedPaused); });
    };
    SoundController.prototype.propogateMuted = function () {
        var _this = this;
        this.propogateValue(function (child) { return child.inheritMuted(_this.accumulatedMuted); });
    };
    SoundController.prototype.propogateRate = function () {
        var _this = this;
        this.propogateValue(function (child) { return child.inheritRate(_this.accumulatedRate); });
    };
    SoundController.prototype.propogateValue = function (accumulator) {
        this._children.forEach(function (child) {
            accumulator(child);
        });
    };
    /**
     * Set the inherited volume and propogate it further down the hierarchy, shouldn't be used except internally within
     * the SoundController hierarchy
     *
     * @param value - the volume to inherit
     * @internal
     */
    SoundController.prototype.inheritVolume = function (value) {
        this.inherited.volume = value;
        this.propogateVolume();
    };
    /**
     * Set the inherited rate and propogate it further down the hierarchy, shouldn't be used except internally within
     * the SoundController hierarchy
     *
     * @param value - the rate to inherit
     * @internal
     */
    SoundController.prototype.inheritRate = function (value) {
        this.inherited.rate = value;
        this.propogateRate();
    };
    /**
     * Set the inherited muted state and propogate it further down the hierarchy, shouldn't be used except internally within
     * the SoundController hierarchy
     *
     * @param value - the muted state to inherit
     * @internal
     */
    SoundController.prototype.inheritMuted = function (value) {
        this.inherited.muted = value;
        this.propogateMuted();
    };
    /**
     * Set the inherited paused state and propogate it further down the hierarchy, shouldn't be used except internally within
     * the SoundController hierarchy
     *
     * @param value - the paused state to inherit
     * @internal
     */
    SoundController.prototype.inheritPaused = function (value) {
        this.inherited.paused = value;
        this.propogatePaused();
    };
    /**
     * Set the inherited state and propogate it further down the hierarchy, shouldn't be used except internally within
     * the SoundController hierarchy
     *
     * @param value - the state to inherit
     * @internal
     */
    SoundController.prototype.inheritState = function (value) {
        this.inherited = Object.assign({}, value);
        this.propogateState();
    };
    Object.defineProperty(SoundController.prototype, "accumulatedVolume", {
        /*
        * These methods calculate the accumulated value of a property based on the property's value on this SoundController
        * combined with the corresponding properties on all of it's ancestors
        */
        get: function () {
            return this.inherited.volume * this.internal.volume;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "accumulatedPaused", {
        get: function () {
            return this.inherited.paused || this.internal.paused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "accumulatedMuted", {
        get: function () {
            return this.inherited.muted || this.internal.muted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "accumulatedRate", {
        get: function () {
            return this.inherited.rate * this.internal.rate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundController.prototype, "accumulatedState", {
        get: function () {
            return {
                volume: this.accumulatedVolume,
                paused: this.accumulatedPaused,
                muted: this.accumulatedMuted,
                rate: this.accumulatedRate,
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * fade volume from it's current value to the specified value
     *
     * @param targetVolume - target volume value
     * @param duration - in seconds, of fade
     * @param  onComplete - optional callback to execute when fade has completed
     */
    SoundController.prototype.fadeTo = function (targetVolume, duration, onComplete) {
        gsap.to(this, duration, { volume: targetVolume, ease: 'none', onComplete: onComplete });
    };
    /**
     * fade volume from 0 to 1
     *
     * @param duration - in seconds, of fade
     * @param onComplete - optional callback to execute when fade has completed
     */
    SoundController.prototype.fadeIn = function (duration, onComplete) {
        this.volume = 0;
        this.fadeTo(1, duration, onComplete);
    };
    /**
     * fade volume to 0
     *
     * @param duration - in seconds, of fade
     * @param onComplete - optional callback to execute when fade has completed
     */
    SoundController.prototype.fadeOut = function (duration, onComplete) {
        this.fadeTo(0, duration, onComplete);
    };
    return SoundController;
}());
export { SoundController };
