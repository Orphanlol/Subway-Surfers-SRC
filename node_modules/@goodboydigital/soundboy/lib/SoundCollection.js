/**
 * Used to determine if sounds are selected in RANDOM or LINEAR order
 */
export var SELECTION_MODE;
(function (SELECTION_MODE) {
    /**
     * sounds in the collection will be picked in a random order
     */
    SELECTION_MODE["RANDOM"] = "random";
    /**
     * sounds in the collection will be picked in order
     */
    SELECTION_MODE["LINEAR"] = "linear";
})(SELECTION_MODE || (SELECTION_MODE = {}));
/**
 * Used to determine whether playing a collection will pick a SINGLE sound to play, or play all the valid sounds in the collection
 * one after the other as a GROUP
 *
 */
export var SEQUENCE_MODE;
(function (SEQUENCE_MODE) {
    /**
     * sounds in the collection will be picked and played one at a time
     */
    SEQUENCE_MODE["SINGLE"] = "single";
    /**
     * one or more sounds provided by the collection data will play in sequence as if they were a single sound instance
     */
    SEQUENCE_MODE["GROUP"] = "group";
})(SEQUENCE_MODE || (SEQUENCE_MODE = {}));
/**
 * by default a collection will play a single sound each time selected at random,
 */
var defaultData = {
    selectionMode: SELECTION_MODE.RANDOM,
    sequenceMode: SEQUENCE_MODE.SINGLE,
};
var uid = 1;
var SoundCollection = /** @class */ (function () {
    function SoundCollection(data) {
        this.selectionMode = SELECTION_MODE.RANDOM;
        this.sequenceMode = SEQUENCE_MODE.SINGLE;
        this.children = [];
        this.matchingChildren = [];
        this.usedChildren = [];
        this.id = data.id;
        data = Object.assign({}, defaultData, data);
        // assign unique id if none supplied (root collections should have an id, child ids can be safely generated)
        if (!data.id)
            data.id = "uid_" + uid++;
        this.selectionMode = data.selectionMode;
        this.sequenceMode = data.sequenceMode;
        this.filter = data.filter;
        if (data.children) {
            this.children = data.children.map(function (data) { return new SoundCollection(data); });
        }
    }
    SoundCollection.prototype.addItem = function (item) {
        this.children.push(item);
    };
    SoundCollection.prototype.removeAll = function () {
        this.children = [];
    };
    /**
    * returns an array of one or more sound ids that should be played in sequence
    **/
    SoundCollection.prototype.getSequence = function (filter) {
        return this.buildSequence(filter, this);
    };
    /**
    * returns the next valid item in this collection
    **/
    SoundCollection.prototype.getItem = function (filterItem) {
        if (filterItem === void 0) { filterItem = null; }
        if (this.children.length === 0) {
            // no children, this is a single instance
            if (this.applyFilter(this, filterItem))
                return this;
            return null;
        }
        this.setMatchingChildren(filterItem);
        if (this.matchingChildren.length === 0) {
            if (this.usedChildren.length === 0) {
                return null;
            }
            this.resetUsedChildren();
            this.setMatchingChildren(filterItem);
        }
        // there were no, are no, and never will be any matching items for this filter
        if (this.matchingChildren.length === 0) {
            return null;
        }
        var index;
        switch (this.selectionMode) {
            case SELECTION_MODE.LINEAR:
                index = 0;
                break;
            // case SELECTION_MODE_RANDOM:
            default:
                index = Math.floor(Math.random() * this.matchingChildren.length);
        }
        var item = this.matchingChildren.splice(index, 1)[0];
        this.usedChildren.push(item);
        return item;
    };
    Object.defineProperty(SoundCollection.prototype, "playedAll", {
        get: function () {
            if (this.matchingChildren.length === 0)
                this.resetUsedChildren();
            return this.matchingChildren.length === 0 || this.children.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundCollection.prototype, "hasChildren", {
        get: function () {
            return this.numChildren > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundCollection.prototype, "numChildren", {
        get: function () {
            return this.children.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundCollection.prototype, "singleMode", {
        get: function () {
            return this.sequenceMode === SEQUENCE_MODE.SINGLE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SoundCollection.prototype, "parent", {
        get: function () {
            return this.parent;
        },
        enumerable: true,
        configurable: true
    });
    SoundCollection.prototype.resetUsedChildren = function () {
        this.usedChildren = [];
    };
    SoundCollection.prototype.applyFilter = function (collection, filterItem) {
        return collection.filter === null || filterItem === null || filterItem.test(collection.filter);
    };
    SoundCollection.prototype.setMatchingChildren = function (filter) {
        var _this = this;
        this.matchingChildren = this.children.filter(function (child) {
            return _this.applyFilter(child, filter) && _this.usedChildren.indexOf(child) === -1;
        });
    };
    SoundCollection.prototype.buildSequence = function (filter, collection, sequence) {
        // create sequence if none
        if (!sequence)
            sequence = [];
        // get item from SoundCollection (might be the collection itself or a valid child collection)
        var item = collection.getItem(filter);
        /* if( item == null )
            return sequence;
            // do something*/
        if (item !== null && !item.hasChildren) {
            // end of branch, add sound
            sequence.push(item.id);
        }
        else if (item !== null) {
            // dig deeper
            this.buildSequence(filter, item, sequence);
        }
        if (item === null || item === collection || (collection.playedAll || collection.singleMode)) {
            // no more to do in this collection
        }
        else {
            // add next sound from currentCollection
            this.buildSequence(filter, collection, sequence);
        }
        return sequence;
    };
    return SoundCollection;
}());
export { SoundCollection };
