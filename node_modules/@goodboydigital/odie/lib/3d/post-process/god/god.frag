export default "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float uExposure ;\nuniform float uWeight;\nuniform float uDecay;\nuniform float uDensity;\nuniform int uNumSamples;\nuniform vec3 uGodColor;\n\n\nvec3 godrays(\n    float density,\n    float weight,\n    float decay,\n    float exposure,\n    int numSamples,\n    sampler2D occlusionTexture,\n    vec2 screenSpaceLightPos,\n    vec2 uv\n    ) {\n\n    vec3 fragColor = vec3(0.0,0.0,0.0);\n    \n\tvec2 deltaTextCoord = vec2( uv - screenSpaceLightPos.xy );\n\n\tvec2 textCoo = uv.xy ;\n\tdeltaTextCoord *= (1.0 /  float(numSamples)) * density;\n\tfloat illuminationDecay = 1.0;\n\n\n\tfor(int i=0; i < 100 ; i++){\n        /*\n        This makes sure that the loop only runs `numSamples` many times.\n        We have to do it this way in WebGL, since you can't have a for loop\n        that runs a variable number times in WebGL.\n        This little hack gets around that.\n        But the drawback of this is that we have to specify an upper bound to the\n        number of iterations(but 100 is good enough for almost all cases.)\n        */\n\t    if(numSamples < i) {\n            break;\n\t    }\n\n\t\ttextCoo -= deltaTextCoord;\n\t\tvec4 samp = texture2D(occlusionTexture, textCoo   );//.xyz;\n\t\tvec3 outty = mix(vec4(uGodColor, 1.), vec4(0.), samp.a).xyz;\n\n      outty *= illuminationDecay * weight;\n\t\tfragColor += outty;\n\t\tilluminationDecay *= decay;\n\t}\n\n\tfragColor *= exposure;\n\n    return fragColor;\n}\n\nvoid main(void)\n{\n   vec2 uScreenSpaceSunPos = vec2(0.5, 0.9);\n\n   vec3 fragColor = godrays(\n    uDensity, uWeight, uDecay, uExposure, uNumSamples, uSampler, uScreenSpaceSunPos, vTextureCoord\n   );\n\n   vec4 rays = vec4(fragColor, 1.);\n   vec4 color = texture2D(uSampler, vTextureCoord);\n\n   gl_FragColor =  (rays *3.);\n}\n"